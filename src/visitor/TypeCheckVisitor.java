package visitor;import syntaxtree.*;import symboltable.SymbolTable;import symboltable.Class;import symboltable.Method;public class TypeCheckVisitor extends DepthFirstVisitor {	protected static Class classeAtual;	protected static Method metodoAtual;	protected static SymbolTable tabelaDeSimbolos;	//Inicializando a tabela de simbolos para executar o verificacao de tipos	public TypeCheckVisitor(SymbolTable st){		tabelaDeSimbolos = st;	}	// Um programa possui uma MainClass m e um ClassDeclList cl	public void visit(Program n) {		n.m.accept(this);		ClassDeclList cdl = n.cl;		//Para cada elemento de ClassDeclList, chamar o metodo accept		for ( int i = 0; i < n.cl.size(); i++ ) {			cdl.elementAt(i).accept(this);		}	}	// A MainClass possui dois identifiers i1 e i2 e possui um statement s	public void visit(MainClass n) {		classeAtual = tabelaDeSimbolos.getClass(n.i1.toString());		n.i2.accept(this);		n.s.accept(this);	}	// ClassDeclSimple possui um identifier i, uma VarDeclList vl e uma MethodDeclList ml	public void visit(ClassDeclSimple n) {		Identifier i = n.i;		VarDeclList vdl = n.vl;		MethodDeclList mdl = n.ml;		classeAtual = tabelaDeSimbolos.getClass(i.toString());		for ( int j = 0; j < vdl.size(); j++ ) {			vdl.elementAt(j).accept(this);		}		for ( int j = 0; j < mdl.size(); j++ ) {			mdl.elementAt(j).accept(this);		}	}	// ClassDeclExtends possui um identifier i e um identifier j, uma VarDeclList vl e uma MethodDeclList ml	public void visit(ClassDeclExtends n) {		Identifier i = n.i;		Identifier j = n.j;		VarDeclList vdl = n.vl;		MethodDeclList mdl = n.ml;		classeAtual = tabelaDeSimbolos.getClass(i.toString());		j.accept(this);		for ( int k = 0; k < vdl.size(); k++ ) {			vdl.elementAt(k).accept(this);		}		for ( int k = 0; k < mdl.size(); k++ ) {			mdl.elementAt(k).accept(this);		}	}	public void visit(VarDecl n) {		Type t = n.t;		Identifier i = n.i;		t.accept(this);		i.accept(this);	}	public void visit(MethodDecl n) {		Type t = n.t;		Identifier i = n.i;		FormalList fl = n.fl;		VarDeclList vdl = n.vl;		StatementList sl = n.sl;		Exp e = n.e;		t.accept(this);		metodoAtual = classeAtual.getMethod(i.toString());		Type retorno = metodoAtual.type();		for ( int j = 0; j < n.fl.size(); j++ ) {			fl.elementAt(j).accept(this);		}		for ( int j = 0; j < n.vl.size(); j++ ) {			vdl.elementAt(j).accept(this);		}		for ( int j = 0; j < n.sl.size(); j++ ) {			sl.elementAt(j).accept(this);		}		if (tabelaDeSimbolos.compareTypes(retorno, e.accept(new TypeCheckExpVisitor()))==false){			CompilerExceptions.printError("Tipo de retorno do metodo "+ i.toString()+ " esta errado.");		}	}	public void visit(Formal n) {		Type t = n.t;		Identifier i = n.i;		t.accept(this);		i.accept(this);	}	public void visit(If n) {		Exp e = n.e;		Statement s1 = n.s1;		Statement s2 = n.s2;		if (! (e.accept(new TypeCheckExpVisitor()) instanceof BooleanType) ) {			CompilerExceptions.printError("A condicao do if deve ser do tipo booleano.");		}		s1.accept(this);		s2.accept(this);	}	public void visit(While n) {		Exp e = n.e;		Statement s = n.s;		if (! (e.accept(new TypeCheckExpVisitor()) instanceof BooleanType) ) {			CompilerExceptions.printError("A condicao do if deve ser do tipo booleano.");		}		s.accept(this);	}	public void visit(Print n) {		if (! (n.e.accept(new TypeCheckExpVisitor()) instanceof IntegerType) ) {			CompilerExceptions.printError("O argumento de System.out.println deve ser do tipo inteiro");		}	}	public void visit(Assign n) {		Type t1 = tabelaDeSimbolos.getVarType(metodoAtual,classeAtual,n.i.toString());		Type t2 = n.e.accept(new TypeCheckExpVisitor() );		if (tabelaDeSimbolos.compareTypes(t1,t2)==false){			CompilerExceptions.printError("Erro de atribuicao em: " + n.i.toString());		}	}	public void visit(ArrayAssign n) {		Identifier i = n.i;		Exp e1 = n.e1;		Exp e2 = n.e2;		Type tipo = tabelaDeSimbolos.getVarType(metodoAtual,classeAtual,i.toString());		if (! (tipo instanceof IntArrayType) ) {			CompilerExceptions.printError("O identificador na atribuicao de uma array deve ser do tipo int[]");		}		if (! (e1.accept(new TypeCheckExpVisitor()) instanceof IntegerType) ) {			CompilerExceptions.printError("A primeira expressao deve ser do tipo inteiro.");		}		if (! (e2.accept(new TypeCheckExpVisitor()) instanceof IntegerType) ) {			CompilerExceptions.printError("A segunda expressao deve ser do tipo inteiro.");		}	}}