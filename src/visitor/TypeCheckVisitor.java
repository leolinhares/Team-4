package visitor;import syntaxtree.*;public class TypeCheckVisitor extends DepthFirstVisitor {	protected static Class classeAtual;	protected static Method metodoAtual;	protected static SymbolTable tabelaDeSimbolos;	//Inicializando a tabela de simbolos para executar o verificacao de tipos	public TypeCheckVisitor(SymbolTable st){		tabelaDeSimbolos = st;	}	// Um programa possui uma MainClass m e um ClassDeclList cl	public void visit(Program n) {		n.m.accept(this);		ClassDeclList cdl = n.cl;		//Para cada elemento de ClassDeclList, chamar o metodo accept		for (int i = 0; i < n.cl.size(); i++) {			cdl.elementAt(i).accept(this);		}	}	// A MainClass possui dois identifiers i1 e i2 e possui um statement s	public void visit(MainClass n) {		classeAtual = tabelaDeSimbolos.getClass(n.i1.toString());		n.i2.accept(this);		n.s.accept(this);	}		// ClassDeclSimple possui um identifier i, uma VarDeclList vl e uma MethodDeclList ml	public void visit(ClassDeclSimple n) {		Identifier i = n.i;		VarDeclList vdl = n.vl;		MethodDeclList mdl = n.ml;				classeAtual = tabelaDeSimbolos.getClass(i.toString());		for (int j = 0; j < vdl.size(); j++) {			vdl.elementAt(j).accept(this);		}		for (int j = 0; j < mdl.size(); j++) {			mdl.elementAt(j).accept(this);		}	}	// ClassDeclExtends possui um identifier i e um identifier j, uma VarDeclList vl e uma MethodDeclList ml	public void visit(ClassDeclExtends n) {		Identifier i = n.i;		Identifier j = n.j;		VarDeclList vdl = n.vl;		MethodDeclList mdl = n.ml;				classeAtual = tabelaDeSimbolos.getClass(i.toString());				j.accept(this);		for (int k = 0; k < vdl.size(); k++) {			vdl.elementAt(k).accept(this);		}		for (int k = 0; k < mdl.size(); k++) {			mdl.elementAt(k).accept(this);		}	}	public void visit(VarDecl n) {		Type t = n.t;		Identifier i = n.i;		t.accept(this);		i.accept(this);	}	//TODO: revisar o if	public void visit(MethodDecl n) {		Type t = n.t;		Identifier i = n.i;		FormalList fl = n.fl;		VarDeclList vdl = n.vl;		StatementList sl = n.sl;		Exp e = n.e;				t.accept(this);				metodoAtual = classeAtual.getMethod(i.toString());				Type retorno = metodoAtual.type();				for (int j = 0; j < n.fl.size(); j++) {			fl.elementAt(j).accept(this);		}		for (int j = 0; j < n.vl.size(); j++) {			vdl.elementAt(j).accept(this);		}		for (int j = 0; j < n.sl.size(); j++) {			sl.elementAt(j).accept(this);		}		if (tabelaDeSimbolos.compareTypes(retorno, e.accept(new TypeCheckExpVisitor()))==false){			System.out.println("Tipo de retorno errado para o método " + i.toString());			System.exit(0);		}	}	public void visit(Formal n) {		Type t = n.t;		Identifier i = n.i;		t.accept(this);		i.accept(this);	}	//TODO: revisar o if	public void visit(If n) {		Exp e = n.e;		Statement s1 = n.s1;		Statement s2 = n.s2;				if (!(e.accept(new TypeCheckExpVisitor()) instanceof BooleanType)) {			System.out.println("A condição de while deve ser do tipo boolean");			System.exit(-1);		}		s1.accept(this);		s2.accept(this);	}		//TODO: revisar o if	//TODO: revisar o if	public void visit(While n) {		Exp e = n.e;		Statement s = n.s;				if (!(e.accept(new TypeCheckExpVisitor()) instanceof BooleanType)) {			System.out.println("A condição de while deve ser do tipo boolean");			System.exit(-1);		}		s.accept(this);	}	// Exp e;	public void visit(Print n) {		if (!(n.e.accept(new TypeCheckExpVisitor()) instanceof IntegerType)) {			System.out.println("O argumento de System.out.println deve ser do tipo int");			System.exit(-1);		}	}	// Identifier i;	// Exp e;	public void visit(Assign n) {		Type t1 = tabelaDeSimbolos.getVarType(metodoAtual,classeAtual,n.i.toString());		Type t2 = n.e.accept(new TypeCheckExpVisitor() );		if (tabelaDeSimbolos.compareTypes(t1,t2)==false){			System.out.println("Erro de tipo na atribuição de " + n.i.toString());				System.exit(0);		}	}	// Identifier i;	// Exp e1,e2;	public void visit(ArrayAssign n) {		Type typeI = tabelaDeSimbolos.getVarType(metodoAtual,classeAtual,n.i.toString());		if (!(typeI instanceof IntArrayType)) {			System.out.println("O identificador em uma atribuição de array deve ser do tipo int []");			System.exit(-1);		}		if (!(n.e1.accept(new TypeCheckExpVisitor()) instanceof IntegerType)) {			System.out.println("A primeira expressão em uma atribuição de array deve ser do tipo int");			System.exit(-1);		}		if (!(n.e2.accept(new TypeCheckExpVisitor()) instanceof IntegerType)) {			System.out.println("A segunda expressão em uma atribuição de array deve ser do tipo int");			System.exit(-1);		}	}}