package visitor;import symboltable.Method;import syntaxtree.*;public class TypeCheckExpVisitor extends TypeDepthFirstVisitor{	public Type visit(Minus minus) {		Exp expressaoEsquerda = minus.e1;		Exp expressaoDireita = minus.e2;				if (!(expressaoDireita.accept(this) instanceof IntegerType)){			CompilerExceptions.printError("A expressão do lado direito do operador '-' deve ser do tipo inteiro.");			}		if (!(expressaoEsquerda.accept(this) instanceof IntegerType)){			CompilerExceptions.printError("A expressão do lado esquerdo do operador '-' deve ser do tipo inteiro.");			}		return new IntegerType();	}	public Type visit(Plus plus) {				Exp expressaoEsquerda = plus.e1;		Exp expressaoDireita = plus.e2;				if (! (expressaoEsquerda.accept(this) instanceof IntegerType) ) {			CompilerExceptions.printError("A expressão do lado esquerdo do operador '+' deve ser do tipo inteiro.");		}		if (! (expressaoDireita.accept(this) instanceof IntegerType) ) {			CompilerExceptions.printError("A expressão do lado direito do operador '+' deve ser do tipo inteiro.");			}		return new IntegerType();	}	public Type visit(Times times) {		Exp expressaoEsquerda = times.e1;		Exp expressaoDireita = times.e2;				if (! (expressaoEsquerda.accept(this) instanceof IntegerType) ) {			CompilerExceptions.printError("A expressão do lado esquerdo do operador '*' deve ser do tipo inteiro.");		}		if (! (expressaoDireita.accept(this) instanceof IntegerType) ) {			CompilerExceptions.printError("A expressão do lado direito do operador '*' deve ser do tipo inteiro.");			}		return new IntegerType();	}	public Type visit(LessThan lessThan) {		Exp expressaoEsquerda = lessThan.e1;		Exp expressaoDireita = lessThan.e2;				if (! (expressaoEsquerda.accept(this) instanceof IntegerType) ) {			CompilerExceptions.printError("A expressão do lado esquerdo do operador '<' deve ser do tipo inteiro.");		}		if (! (expressaoDireita.accept(this) instanceof IntegerType) ) {			CompilerExceptions.printError("A expressão do lado direito do operador '<' deve ser do tipo inteiro.");		}		return new BooleanType();	}	public Type visit(And and) {		Exp expressao1 = and.e1;		Exp expressao2 = and.e2;		if (! (expressao1.accept(this) instanceof BooleanType) ) {			CompilerExceptions.printError("A expressão do lado esquerdo do operador '&&' deve ser do tipo inteiro.");		}		if (! (expressao2.accept(this) instanceof BooleanType) ) {			CompilerExceptions.printError("A expressão do lado direito do operador '&&' deve ser do tipo inteiro.");		}		return new BooleanType();	}	public Type visit(ArrayLookup arrayLookup) {		Exp expressao1 = arrayLookup.e1;		Exp expressao2 = arrayLookup.e2;		if (! (expressao1.accept(this) instanceof IntArrayType) ) {			CompilerExceptions.printError("O indice do vetor deve ser do tipo inteiro.");		}		if (! (expressao2.accept(this) instanceof IntegerType) ) {			CompilerExceptions.printError("O valor a ser atribuido deve ser do tipo inteiro.");		}		return new IntegerType();	}	public Type visit(ArrayLength arrayLength) {		Exp e = arrayLength.e;		if (! (e.accept(this) instanceof IntArrayType) ) {			CompilerExceptions.printError("A expressão deve ser do tipo inteiro.");		}		return new IntegerType();	}	public Type visit(Call call) {		Exp e = call.e;		Identifier i = call.i;		ExpList el = call.el;				if (! (e.accept(this) instanceof IdentifierType)){			CompilerExceptions.printError("O metodo "+ i.toString() + "chamou algo que nao eh uma classe ou objeto.");		} 		String cname = ((IdentifierType) e.accept(this)).s;		Method calledMethod = TypeCheckVisitor.tabelaDeSimbolos.getMethod(i.toString(),cname);		for ( int k = 0; k < el.size(); k++ ) {     				Type t1 =null;  			Type t2 =null;  			if (calledMethod.getParamAt(k)!=null)				t1 = calledMethod.getParamAt(k).type();			t2 = el.elementAt(k).accept(this);			if (!TypeCheckVisitor.tabelaDeSimbolos.compareTypes(t1,t2)){				CompilerExceptions.printError("Tipo dos argumentos de "+ cname + "." + i.toString());			}	    		}		return TypeCheckVisitor.tabelaDeSimbolos.getMethodType(i.toString(),cname);	}	public Type visit(True n) {		return new BooleanType();	}		public Type visit(IntegerLiteral n) {		return new IntegerType();	}	public Type visit(False n) {		return new BooleanType();	}	public Type visit(IdentifierExp n) {      		return TypeCheckVisitor.tabelaDeSimbolos.getVarType(TypeCheckVisitor.metodoAtual,				TypeCheckVisitor.classeAtual,n.s);	}	public Type visit(This n) {		return TypeCheckVisitor.classeAtual.type();	}	public Type visit(NewObject n) {		return new IdentifierType(n.i.s);	}	public Type visit(NewArray newArray) {		Exp e = newArray.e;		if (! (e.accept(this) instanceof IntegerType) ) {			CompilerExceptions.printError("A expressão deve ser do tipo inteiro.");		}		return new IntArrayType();	}	public Type visit(Not not) {		Exp e = not.e;		if (! (e.accept(this) instanceof BooleanType) ) {			CompilerExceptions.printError("A expressão deve ser do tipo inteiro.");		}		return new BooleanType();	}}