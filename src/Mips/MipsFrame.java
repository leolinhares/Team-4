package Mips;import java.util.HashMap;import Temp.Temp;import Temp.Label;import Frame.Frame;import Frame.Access;import Frame.AccessList;public class MipsFrame extends Frame{  private static HashMap functions = new HashMap();  private static HashMap labels    = new HashMap();  public Frame newFrame(String name, int argCount)  {    return new MipsFrame(name, argCount);  }  private MipsFrame(String n, int argCount)  {    Integer count = ((Integer) functions.get(n));    if (count == null)      {        count = new Integer(0);        name = new Label(n);      }    else      {        count = new Integer(count.intValue() + 1);        name = new Label(n + "." + count);      }    functions.put(n, count);    formals = null;    if (argCount > 0)      formals = new AccessList(new InReg(A0), formals);    if (argCount > 1)      formals = new AccessList(new InReg(A1), formals);    if (argCount > 2)      formals = new AccessList(new InReg(A2), formals);    if (argCount > 3)      formals = new AccessList(new InReg(A3), formals);    int offset = 0;    for (int i = 4; i < argCount; i++)      {        offset += wordSize;        formals = new AccessList(new InFrame(offset), formals);      }    Temp.reset();  }  public MipsFrame()  {  }  private static final int wordSize = 4;  public int wordSize()  {    return wordSize;  }  /* offset from frame pointer, updated by allocLocal() */  public int offset = 0;  public Access allocLocal(boolean escape)  {    if (escape)      {        Access result = new InFrame(offset);        offset -= wordSize;        return result;      }    else      return new InReg(new Temp());  }  static final Temp ZERO = new Temp(); // zero reg  static final Temp AT   = new Temp(); // reserved for assembler  static final Temp V0   = new Temp(); // function result  static final Temp V1   = new Temp(); // second function result  static final Temp A0   = new Temp(); // argument1  static final Temp A1   = new Temp(); // argument2  static final Temp A2   = new Temp(); // argument3  static final Temp A3   = new Temp(); // argument4  static final Temp T0   = new Temp(); // T0-T7: caller-saved  static final Temp T1   = new Temp();  static final Temp T2   = new Temp();  static final Temp T3   = new Temp();  static final Temp T4   = new Temp();  static final Temp T5   = new Temp();  static final Temp T6   = new Temp();  static final Temp T7   = new Temp();  static final Temp S0   = new Temp(); // S0-S7: callee-saved  static final Temp S1   = new Temp();  static final Temp S2   = new Temp();  static final Temp S3   = new Temp();  static final Temp S4   = new Temp();  static final Temp S5   = new Temp();  static final Temp S6   = new Temp();  static final Temp S7   = new Temp();  static final Temp T8   = new Temp(); // T8-T9: caller-saved  static final Temp T9   = new Temp();  static final Temp K0   = new Temp(); // reserved for OS kernel  static final Temp K1   = new Temp(); // reserved for OS kernel  static final Temp GP   = new Temp(); // pointer to global area  static final Temp SP   = new Temp(); // stack pointer  static final Temp S8   = new Temp(); // callee-save (frame pointer)  static final Temp RA   = new Temp(); // return address  public Temp FP()  {    return S8;  }  public Temp RV()  {    return V0;  }  public Temp RA()  {    return RA;  }  public Temp T0()  {    return T0;  }  public Temp T1()  {    return T1;  }  public Temp T2()  {    return T2;  }  public Temp T3()  {    return T3;  }  public Tree.Exp externalCall(String s, Tree.ExpList args)  {    String func = s.intern();    Label l = (Label) labels.get(func);    if (l == null)      {        l = new Label("_" + func);        labels.put(func, l);      }    return new Tree.CALL(new Tree.NAME(l), args);  }  private static final HashMap tempMap = new HashMap(32);  static    {      tempMap.put(ZERO, "$0");      tempMap.put(AT, "$at");      tempMap.put(V0, "$v0");      tempMap.put(V1, "$v1");      tempMap.put(A0, "$a0");      tempMap.put(A1, "$a1");      tempMap.put(A2, "$a2");      tempMap.put(A3, "$a3");      tempMap.put(T0, "$t0");      tempMap.put(T1, "$t1");      tempMap.put(T2, "$t2");      tempMap.put(T3, "$t3");      tempMap.put(T4, "$t4");      tempMap.put(T5, "$t5");      tempMap.put(T6, "$t6");      tempMap.put(T7, "$t7");      tempMap.put(S0, "$s0");      tempMap.put(S1, "$s1");      tempMap.put(S2, "$s2");      tempMap.put(S3, "$s3");      tempMap.put(S4, "$s4");      tempMap.put(S5, "$s5");      tempMap.put(S6, "$s6");      tempMap.put(S7, "$s7");      tempMap.put(T8, "$t8");      tempMap.put(T9, "$t9");      tempMap.put(K0, "$k0");      tempMap.put(K1, "$k1");      tempMap.put(GP, "$gp");      tempMap.put(SP, "$sp");      tempMap.put(S8, "$fp");      tempMap.put(RA, "$ra");    }  public String tempMap(Temp temp)  {    return ((String) tempMap.get(temp));  }  public Assem.InstrList codegen(Tree.Stm stm)  {      return null;   // in Stage 5, codegen instruction goes here  }  public String mjLibrary()  {      return "\t.text\n" + "\t.globl _printInt\n" + "_printInt:\n" + "\tli $v0, 1      # load print_int code\n"	  + "\tsyscall        # integer already in $a0\n" + "\tla $a0, _newl  # load newl string\n"	  + "\tli $v0, 4      # load print_string code\n" + "\tsyscall\n" + "\tjr $ra         # return to caller\n\n"	  + "\t.data\n" + "_newl:\n" + "\t.asciiz \"\\n\"\n\n" + "\t.text\n" + "\t.globl _alloc\n" + "_alloc:\n"	  + "\tli $v0, 9      # load sbrk code\n" + "\tsyscall        # size already in $a0\n"	  + "\tjr $ra         # ptr to memory already in $v0\n\n" + "\t.text\n" + "\t.globl _finish\n" + "_finish:\n"	  + "\tli $v0, 10     # load exit code\n" + "\tsyscall        # end execution\n\n"; } }