options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
  public class MiniJavaParser {}
PARSER_END(MiniJavaParser)

/* For the regular expressions on the right, the token on the left will be returned: */
TOKEN : {
< #DIGIT: ["0"-"9"] >
| < #LETTER: (["a"-"z"]|["A"-"Z"]) >
| < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACK: "[" >
| < RBRACK: "]" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < SEMI: ";" >
| < COMMA: "," >
| < IF: "if" >
| < ELSE: "else" >
| < WHILE: "while" >
| < EXTENDS: "extends" >
| < RETURN: "return" >
| < CLASS: "class" >
| < PUBLIC: "public" >
| < STATIC: "static" >
| < VOID: "void" >
| < MAIN: "main" >
| < THIS: "this" >
| < NEW: "new" >
| < NOT: "!" >
| < STRING: "String" >
| < BOOLEAN: "boolean" >
| < INT: "int" >
| < TRUE: "true" >
| < FALSE: "false" >
| < LENGTH: "length" >
| < DOT: "." >
| < SYSO: "System.out.println" >
| < AND: "&&" >
| < LT: "<" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < ASSIGN: "=" >
}

TOKEN : {
< IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|"_")* >
| < INTEGER_LITERAL: (["1"-"9"](<DIGIT>)*) | "0">
}


/* The regular expressions here will be skipped during lexical analysis: white space*/
SKIP : {
" "
| "\t"
| "\n"
| "\r"
| "\f"
| "\r\n"
}

SPECIAL_TOKEN : {
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

void Goal() :
{}
{
  ( MiniJavaToken() )*
  <EOF>
}

void MiniJavaToken():
{}
{

  "class"  |  <IDENTIFIER> | "{" | "public" | "static" | "void" |
  "main" | "(" | "String"  | "[" | "]" | ")" | "}" | "extends" | ";"
  | "return" | "," | "int" | "boolean" | "=" | "if" | "else" | "while"
  | "System.out.println" | "&&" | "<" | "+" | "-" | "*" | "." |
  "length" | <INTEGER_LITERAL> | "true" | "false" | "this" | "new" |
  "!"
}
