options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
  import syntaxtree.*;
  public class MiniJavaParser {}
PARSER_END(MiniJavaParser)

/* For the regular expressions on the right, the token on the left will be returned: */
TOKEN : {
< #DIGIT: ["0"-"9"] >
| < #LETTER: (["a"-"z"]|["A"-"Z"]) >
| < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACK: "[" >
| < RBRACK: "]" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < SEMI: ";" >
| < COMMA: "," >
| < IF: "if" >
| < ELSE: "else" >
| < WHILE: "while" >
| < EXTENDS: "extends" >
| < RETURN: "return" >
| < CLASS: "class" >
| < PUBLIC: "public" >
| < STATIC: "static" >
| < VOID: "void" >
| < MAIN: "main" >
| < THIS: "this" >
| < NEW: "new" >
| < NOT: "!" >
| < STRING: "String" >
| < BOOLEAN: "boolean" >
| < INT: "int" >
| < TRUE: "true" >
| < FALSE: "false" >
| < LENGTH: "length" >
| < DOT: "." >
| < SYSO: "System.out.println" >
| < AND: "&&" >
| < LT: "<" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < ASSIGN: "=" >
}

TOKEN : {
< IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|"_")* >
| < INTEGER_LITERAL: (["1"-"9"](<DIGIT>)*) | "0">
}


/* The regular expressions here will be skipped during lexical analysis: white space*/
SKIP : {
" "
| "\t"
| "\n"
| "\r"
| "\f"
| "\r\n"
}

SPECIAL_TOKEN : {
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

Program Goal() :
{
  MainClass m;
  ClassDeclList cl = new ClassDeclList();
  ClassDecl c;
}
{
	m = MainClass() (c=ClassDecl(){cl.addElement(c);})*
	<EOF>
	{return new Program(m,cl);}
}

MainClass MainClass() :
{
	Statement s;
	Identifier i1;
	Identifier i2;
}

{
	<CLASS> i1=Identifier() <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING> <LBRACK> <RBRACK> i2=Identifier() <RPAREN> <LBRACE> s = Statement() <RBRACE> <RBRACE>
	{return new MainClass(i1,i2,s);}
}

ClassDecl ClassDecl() :
{ClassDecl c;}
{	(LOOKAHEAD(3) c = ClassDeclarationSimple() | c = ClassDeclarationExtends())
	{return c;}
}

ClassDecl ClassDeclarationSimple():
{
Identifier i;
VarDecl v; VarDeclList vl = new VarDeclList();
MethodDecl m; MethodDeclList ml = new MethodDeclList();}
{
  <CLASS> i = Identifier() <LBRACE> (v = VarDecl(){vl.addElement(v);})* (m = MethodDecl(){ml.addElement(m);})* <RBRACE>{return new ClassDeclSimple(i,vl,ml);}
}

ClassDecl ClassDeclarationExtends():
{
Identifier i1,i2;
VarDecl v; VarDeclList vl = new VarDeclList();
MethodDecl m; MethodDeclList ml = new MethodDeclList();
}
{
  <CLASS> i1 = Identifier() <EXTENDS> i2 = Identifier() <LBRACE> (v = VarDecl(){vl.addElement(v);})* (m = MethodDecl(){ml.addElement(m);})* <RBRACE>{return new ClassDeclExtends(i1,i2,vl,ml);}
}

VarDecl VarDecl() :
{Type t; Identifier i;}
{
	t = Type() i = Identifier() <SEMI>
	{return new VarDecl(t,i);}
}

void MethodDecl() :
{
  /*Type t; Identifier i;
  FormalList fl = new FormalList();
  VarDecl v; VarDeclList vl = new VarDeclList();
  Statement s;
  StatementList sl = new StatementList();
  Exp e;*/
}
{
	<PUBLIC> Type() Identifier()
	<LPAREN> FormalList() <RPAREN> <LBRACE> (LOOKAHEAD(2)VarDecl())* (Statement())* <RETURN> Exp() <SEMI> <RBRACE>
}

void FormalList() :
{}
{
	(Type() <IDENTIFIER> (FormalRest())*)?
}

void FormalRest() :
{}
{
	<COMMA> Type() <IDENTIFIER>
}

void Type() :
{}
{
	LOOKAHEAD(2)<INT> <LBRACK> <RBRACK> | <BOOLEAN> | LOOKAHEAD(2)<INT> | Identifier()
}

Identifier Identifier():{Token t;}{
  t=<IDENTIFIER>
  {return new Identifier(t.image);}
}

void Statement() :
{}
{
	<LBRACE> (Statement())* <RBRACE> |
	<IF> <LPAREN> Exp() <RPAREN> Statement() <ELSE> Statement() |
	<WHILE> <LPAREN> Exp() <RPAREN> Statement() |
	<SYSO> <LPAREN> Exp() <RPAREN> <SEMI> |
	LOOKAHEAD(2)<IDENTIFIER> <ASSIGN> Exp() <SEMI> |
	LOOKAHEAD(2)<IDENTIFIER> <LBRACK> Exp() <RBRACK> <ASSIGN> Exp() <SEMI>
}

void Exp() :
{}
{
  	And()
}

void And() :{}{	LessThan() ( <AND> LessThan() )*
}

void LessThan() :{}{	AdditiveExp()[ <LT> AdditiveExp()]
}

void AdditiveExp() :{}{	Times() ((< PLUS>|< MINUS>) Times())*
}

void Times() :{}{	PrefixExp() (<STAR> PrefixExp())*
}

void PrefixExp() :{}{	Not() | PostfixExp()
}

void Not() :{}{
  (<NOT>)+ PostfixExp()}

void PostfixExp() :{}{	PrimaryExp()(<LBRACK> Exp() <RBRACK> |
	 LOOKAHEAD(2)<DOT> <IDENTIFIER> <LPAREN> ExpList() <RPAREN>|
	 LOOKAHEAD(2)<DOT> <LENGTH>)*
}

void PrimaryExp() :{}{	<INTEGER_LITERAL > |	<TRUE> |	<FALSE> |	<IDENTIFIER> |	<THIS> |	LOOKAHEAD(2)<NEW> <INT> <LBRACK> Exp() <RBRACK> |	LOOKAHEAD(2)<NEW> <IDENTIFIER> <LPAREN> <RPAREN> |	<LPAREN> Exp() <RPAREN>
}

void ExpList() :
{}
{
	(Exp() (ExpRest())*)?
}

void ExpRest() :
{}
{
	<COMMA> Exp()
}