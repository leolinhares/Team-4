options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
  public class MiniJavaParser {}
PARSER_END(MiniJavaParser)

/* For the regular expressions on the right, the token on the left will be returned: */
TOKEN : {
< #DIGIT: ["0"-"9"] >
| < #LETTER: (["a"-"z"]|["A"-"Z"]) >
| < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACK: "[" >
| < RBRACK: "]" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < SEMI: ";" >
| < COMMA: "," >
| < IF: "if" >
| < ELSE: "else" >
| < WHILE: "while" >
| < EXTENDS: "extends" >
| < RETURN: "return" >
| < CLASS: "class" >
| < PUBLIC: "public" >
| < STATIC: "static" >
| < VOID: "void" >
| < MAIN: "main" >
| < THIS: "this" >
| < NEW: "new" >
| < NOT: "!" >
| < STRING: "String" >
| < BOOLEAN: "boolean" >
| < INT: "int" >
| < TRUE: "true" >
| < FALSE: "false" >
| < LENGTH: "length" >
| < DOT: "." >
| < SYSO: "System.out.println" >
| < AND: "&&" >
| < LT: "<" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < ASSIGN: "=" >
}

TOKEN : {
< IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|"_")* >
| < INTEGER_LITERAL: (["1"-"9"](<DIGIT>)*) | "0">
}


/* The regular expressions here will be skipped during lexical analysis: white space*/
SKIP : {
" "
| "\t"
| "\n"
| "\r"
| "\f"
| "\r\n"
}

SPECIAL_TOKEN : {
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

void Program() :
{}
{
	MainClass() (ClassDecl())* <EOF>
}

void MainClass() :
{}
{
	<CLASS> <IDENTIFIER> <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING> <LBRACK> <RBRACK> <IDENTIFIER> <RPAREN> <LBRACE> Statement() <RBRACE> <RBRACE>
}

void ClassDecl() :
{}
{
	LOOKAHEAD(3)<CLASS> <IDENTIFIER> <LBRACE> (VarDecl())* (MethodDecl())* <RBRACE> |
	LOOKAHEAD(3)<CLASS> <IDENTIFIER> <EXTENDS> <IDENTIFIER> <LBRACE> (VarDecl())* (MethodDecl())* <RBRACE>
}

void VarDecl() :
{}
{
	Type() <IDENTIFIER> <SEMI>
}

void MethodDecl() :
{}
{
	<PUBLIC> Type() <IDENTIFIER> <LPAREN> FormalList() <RPAREN> <LBRACE> (LOOKAHEAD(2)VarDecl())* (Statement())* <RETURN> Exp() <SEMI> <RBRACE>
}

void FormalList() :
{}
{
	(Type() <IDENTIFIER> (FormalRest())*)?
}

void FormalRest() :
{}
{
	<COMMA> Type() <IDENTIFIER>
}

void Type() :
{}
{
	LOOKAHEAD(2)<INT> <LBRACK> <RBRACK> | <BOOLEAN> | LOOKAHEAD(2)<INT> | <IDENTIFIER>
}

void Statement() :
{}
{
	<LBRACE> (Statement())* <RBRACE> |
	<IF> <LPAREN> Exp() <RPAREN> Statement() <ELSE> Statement() |
	<WHILE> <LPAREN> Exp() <RPAREN> Statement() |
	<SYSO> <LPAREN> Exp() <RPAREN> <SEMI> |
	LOOKAHEAD(2)<IDENTIFIER> <ASSIGN> Exp() <SEMI> |
	LOOKAHEAD(2)<IDENTIFIER> <LBRACK> Exp() <RBRACK> <ASSIGN> Exp() <SEMI>
}

void Exp() :
{}
{
  	And()
}

void And() :{}{	LessThan() ( <AND> LessThan() )*
}

void LessThan() :{}{	AdditiveExp()[ <LT> AdditiveExp()]
}

void AdditiveExp() :{}{	Times() ((< PLUS>|< MINUS>) Times())*
}

void Times() :{}{	PrefixExp() (<STAR> PrefixExp())*
}

void PrefixExp() :{}{	Not() | PostfixExp()
}

void Not() :{}{
  (<NOT>)+ PostfixExp()}

void PostfixExp() :{}{	PrimaryExp()(<LBRACK> Exp() <RBRACK> |
	 LOOKAHEAD(2)<DOT> <IDENTIFIER> <LPAREN> ExpList() <RPAREN>|
	 LOOKAHEAD(2)<DOT> <LENGTH>)*
}

void PrimaryExp() :{}{	<INTEGER_LITERAL > |	<TRUE> |	<FALSE> |	<IDENTIFIER> |	<THIS> |	LOOKAHEAD(2)<NEW> <INT> <LBRACK> Exp() <RBRACK> |	LOOKAHEAD(2)<NEW> <IDENTIFIER> <LPAREN> <RPAREN> |	<LPAREN> Exp() <RPAREN>
}

void ExpList() :
{}
{
	(Exp() (ExpRest())*)?
}

void ExpRest() :
{}
{
	<COMMA> Exp()
}